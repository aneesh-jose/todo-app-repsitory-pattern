// Code generated by nero, DO NOT EDIT.
package todorepo

import (
	"context"
	"fmt"
	"reflect"

	"github.com/aneesh-jose/sample-todo/models"
	multierror "github.com/hashicorp/go-multierror"
	"github.com/pkg/errors"
	"github.com/sf9v/nero"
)

// Repository is an interface for interacting with a Todo repository
type Repository interface {
	// Tx begins a new transaction
	Tx(context.Context) (nero.Tx, error)
	// Create creates a Todo
	Create(context.Context, *Creator) (id int, err error)
	// CreateTx creates a Todo in a transaction
	CreateTx(context.Context, nero.Tx, *Creator) (id int, err error)
	// CreateMany batch creates Todos
	CreateMany(context.Context, ...*Creator) error
	// CreateManyTx batch creates Todos in a transaction
	CreateManyTx(context.Context, nero.Tx, ...*Creator) error
	// Query queries Todos
	Query(context.Context, *Queryer) ([]*models.Todo, error)
	// QueryTx queries Todos in a transaction
	QueryTx(context.Context, nero.Tx, *Queryer) ([]*models.Todo, error)
	// QueryOne queries a Todo
	QueryOne(context.Context, *Queryer) (*models.Todo, error)
	// QueryOneTx queries a Todo in a transaction
	QueryOneTx(context.Context, nero.Tx, *Queryer) (*models.Todo, error)
	// Update updates a Todo or many Todos
	Update(context.Context, *Updater) (rowsAffected int64, err error)
	// UpdateTx updates a Todo many Todos in a transaction
	UpdateTx(context.Context, nero.Tx, *Updater) (rowsAffected int64, err error)
	// Delete deletes a Todo or many Todos
	Delete(context.Context, *Deleter) (rowsAffected int64, err error)
	// Delete deletes a Todo or many Todos in a transaction
	DeleteTx(context.Context, nero.Tx, *Deleter) (rowsAffected int64, err error)
	// Aggregate runs an aggregate query
	Aggregate(context.Context, *Aggregator) error
	// Aggregate runs an aggregate query in a transaction
	AggregateTx(context.Context, nero.Tx, *Aggregator) error
}

// Creator is a create builder
type Creator struct {
	id          int
	name        string
	description string
	status      bool
	user        string
}

// NewCreator returns a Creator
func NewCreator() *Creator {
	return &Creator{}
}

// Id sets the Id field
func (c *Creator) Id(id int) *Creator {
	c.id = id
	return c
}

// Name sets the Name field
func (c *Creator) Name(name string) *Creator {
	c.name = name
	return c
}

// Description sets the Description field
func (c *Creator) Description(description string) *Creator {
	c.description = description
	return c
}

// Status sets the Status field
func (c *Creator) Status(status bool) *Creator {
	c.status = status
	return c
}

// User sets the User field
func (c *Creator) User(user string) *Creator {
	c.user = user
	return c
}

// Validate validates the fields
func (c *Creator) Validate() error {
	var err error
	if isZero(c.name) {
		err = multierror.Append(err, nero.NewErrRequiredField("name"))
	}

	if isZero(c.description) {
		err = multierror.Append(err, nero.NewErrRequiredField("description"))
	}

	if isZero(c.status) {
		err = multierror.Append(err, nero.NewErrRequiredField("status"))
	}

	if isZero(c.user) {
		err = multierror.Append(err, nero.NewErrRequiredField("user"))
	}

	return err
}

// Queryer is a query builder
type Queryer struct {
	limit  uint
	offset uint
	pfs    []PredFunc
	sfs    []SortFunc
}

// NewQueryer returns a Queryer
func NewQueryer() *Queryer {
	return &Queryer{}
}

// Where applies predicates
func (q *Queryer) Where(pfs ...PredFunc) *Queryer {
	q.pfs = append(q.pfs, pfs...)
	return q
}

// Sort applies sorting expressions
func (q *Queryer) Sort(sfs ...SortFunc) *Queryer {
	q.sfs = append(q.sfs, sfs...)
	return q
}

// Limit applies limit
func (q *Queryer) Limit(limit uint) *Queryer {
	q.limit = limit
	return q
}

// Offset applies offset
func (q *Queryer) Offset(offset uint) *Queryer {
	q.offset = offset
	return q
}

// Updater is an update builder
type Updater struct {
	name        string
	description string
	status      bool
	user        string
	pfs         []PredFunc
}

// NewUpdater returns an Updater
func NewUpdater() *Updater {
	return &Updater{}
}

// Name sets the Name field
func (c *Updater) Name(name string) *Updater {
	c.name = name
	return c
}

// Description sets the Description field
func (c *Updater) Description(description string) *Updater {
	c.description = description
	return c
}

// Status sets the Status field
func (c *Updater) Status(status bool) *Updater {
	c.status = status
	return c
}

// User sets the User field
func (c *Updater) User(user string) *Updater {
	c.user = user
	return c
}

// Where applies predicates
func (u *Updater) Where(pfs ...PredFunc) *Updater {
	u.pfs = append(u.pfs, pfs...)
	return u
}

// Deleter is a delete builder
type Deleter struct {
	pfs []PredFunc
}

// NewDeleter returns a Deleter
func NewDeleter() *Deleter {
	return &Deleter{}
}

// Where applies predicates
func (d *Deleter) Where(pfs ...PredFunc) *Deleter {
	d.pfs = append(d.pfs, pfs...)
	return d
}

// Aggregator is an aggregate query builder
type Aggregator struct {
	v      interface{}
	aggfs  []AggFunc
	pfs    []PredFunc
	sfs    []SortFunc
	groups []Column
}

// NewAggregator expects a v and returns an Aggregator
// where 'v' argument must be an array of struct
func NewAggregator(v interface{}) *Aggregator {
	return &Aggregator{v: v}
}

// Aggregate applies aggregate functions
func (a *Aggregator) Aggregate(aggfs ...AggFunc) *Aggregator {
	a.aggfs = append(a.aggfs, aggfs...)
	return a
}

// Where applies predicates
func (a *Aggregator) Where(pfs ...PredFunc) *Aggregator {
	a.pfs = append(a.pfs, pfs...)
	return a
}

// Sort applies sorting expressions
func (a *Aggregator) Sort(sfs ...SortFunc) *Aggregator {
	a.sfs = append(a.sfs, sfs...)
	return a
}

// Group applies group clauses
func (a *Aggregator) Group(cols ...Column) *Aggregator {
	a.groups = append(a.groups, cols...)
	return a
}

// rollback performs a rollback
func rollback(tx nero.Tx, err error) error {
	rerr := tx.Rollback()
	if rerr != nil {
		err = errors.Wrapf(err, "rollback error: %v", rerr)
	}
	return err
}

// isZero checks if v is a zero-value
func isZero(v interface{}) bool {
	if reflect.TypeOf(v).Kind() == reflect.Bool {
		if v != nil {
			fmt.Println(v)
			return false
		}
	}
	return reflect.ValueOf(v).IsZero()
}
