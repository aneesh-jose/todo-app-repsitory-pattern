// Code generated by nero, DO NOT EDIT.
package userrepo

import (
	"github.com/sf9v/nero/comparison"
)

// PredFunc is a predicate function
type PredFunc func(*comparison.Predicates)

// UsernameEq applies "equal" operator on "username" column
func UsernameEq(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.Eq,
			Arg: username,
		})
	}
}

// UsernameNotEq applies "not equal" operator on "username" column
func UsernameNotEq(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.NotEq,
			Arg: username,
		})
	}
}

// UsernameGt applies "greater than" operator on "username" column
func UsernameGt(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.Gt,
			Arg: username,
		})
	}
}

// UsernameGtOrEq applies "greater than or equal" operator on "username" column
func UsernameGtOrEq(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.GtOrEq,
			Arg: username,
		})
	}
}

// UsernameLt applies "less than" operator on "username" column
func UsernameLt(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.Lt,
			Arg: username,
		})
	}
}

// UsernameLtOrEq applies "less than or equal" operator on "username" column
func UsernameLtOrEq(username string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.LtOrEq,
			Arg: username,
		})
	}
}

// UsernameIn applies "in" operator on "username" column
func UsernameIn(usernames ...string) PredFunc {
	args := []interface{}{}
	for _, v := range usernames {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

// UsernameNotIn applies "not in" operator on "username" column
func UsernameNotIn(usernames ...string) PredFunc {
	args := []interface{}{}
	for _, v := range usernames {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "username",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

// NameEq applies "equal" operator on "name" column
func NameEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Eq,
			Arg: name,
		})
	}
}

// NameNotEq applies "not equal" operator on "name" column
func NameNotEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotEq,
			Arg: name,
		})
	}
}

// NameGt applies "greater than" operator on "name" column
func NameGt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Gt,
			Arg: name,
		})
	}
}

// NameGtOrEq applies "greater than or equal" operator on "name" column
func NameGtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.GtOrEq,
			Arg: name,
		})
	}
}

// NameLt applies "less than" operator on "name" column
func NameLt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Lt,
			Arg: name,
		})
	}
}

// NameLtOrEq applies "less than or equal" operator on "name" column
func NameLtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.LtOrEq,
			Arg: name,
		})
	}
}

// NameIn applies "in" operator on "name" column
func NameIn(names ...string) PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

// NameNotIn applies "not in" operator on "name" column
func NameNotIn(names ...string) PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

// PasswordEq applies "equal" operator on "password" column
func PasswordEq(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.Eq,
			Arg: password,
		})
	}
}

// PasswordNotEq applies "not equal" operator on "password" column
func PasswordNotEq(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.NotEq,
			Arg: password,
		})
	}
}

// PasswordGt applies "greater than" operator on "password" column
func PasswordGt(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.Gt,
			Arg: password,
		})
	}
}

// PasswordGtOrEq applies "greater than or equal" operator on "password" column
func PasswordGtOrEq(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.GtOrEq,
			Arg: password,
		})
	}
}

// PasswordLt applies "less than" operator on "password" column
func PasswordLt(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.Lt,
			Arg: password,
		})
	}
}

// PasswordLtOrEq applies "less than or equal" operator on "password" column
func PasswordLtOrEq(password string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.LtOrEq,
			Arg: password,
		})
	}
}

// PasswordIn applies "in" operator on "password" column
func PasswordIn(passwords ...string) PredFunc {
	args := []interface{}{}
	for _, v := range passwords {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

// PasswordNotIn applies "not in" operator on "password" column
func PasswordNotIn(passwords ...string) PredFunc {
	args := []interface{}{}
	for _, v := range passwords {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "password",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}
